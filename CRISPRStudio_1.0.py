#!/usr/bin/env python3


import sys, os, argparse, re, subprocess, random, fnmatch, glob, fileinput
from collections import OrderedDict, Counter


# The function spacerExtract extracts the spacer information contained
# in the gff3 file generated with CRISPRDetect
def spacerExtract(inFile):
    
    '''
        function:
            -
        input: 
            - inFile is the gff file with generated with CRISPRDetect
        output:
            - spacerDict -> dict structured (spacerDict[sId]=[sSeq, sLen, orientation])
            - isolateList -> list of all the isolates
            - averageLength -> the average length of the spacer
            - crArrayList -> list of all the uniq crId (ex. NZ_ALEL01000035.1||CRISPR1)
    '''

    spacerDict = OrderedDict() # create an empty dictionnary
    isolateList = [] # create an empty list for the isolates
    crArrayList = [] # create an empty list or the CRISPR array
    spacerLength = [] # create an empty list to store the spacer length to calculate the average length
    repeatRegionList = []
    with open(inFile, 'rU') as fl:
        newRepeatRegion = 'T'
        for line in fl:
            array = line.strip().split('\t')
            isolate = array[0]
            start= array[3]
            end= array[4]
            orientation = array[6] 
            if array[2] != 'repeat_region' and newRepeatRegion == 'T':
                if array[2] == 'binding_site':
                    if isolate not in isolateList:
                        isolateList.append(isolate)
                    sArray = array[8].split(';')
                    crId = '||'.join([isolate, sArray[0][3:]])+'||'+sArray[0].split('_')[0][3:]
                    crArrayList.append(crId)
                    for it in sArray:
                        if re.match('Note=', it):
                            sSeq = it[5:]
                            sLen = int(array[5])
                            sId = '||'.join([isolate, sArray[0][3:]])+':'+str(sLen)+':'+orientation
                            # Store the information in a dictionnary
                            spacerDict[sId]=[sSeq, sLen, orientation]
                            spacerLength.append(sLen)
            elif array[2] == 'repeat_region':               
                repeatRegion = isolate+'||'+start+'_'+end
                if repeatRegion not in repeatRegionList:
                    repeatRegionList.append(repeatRegion)
                    newRepeatRegion = 'T'
                else:
                    newRepeatRegion = 'F'
                    
    averageLength = sum(spacerLength)/float(len(spacerLength))

    #return the dict, the isolateList, the averagelength and the crArrayList

    return(spacerDict, isolateList, averageLength, crArrayList)

def checkSpacer(spacerDict, averageLength, outFasta):
    '''
        definition: 

        input:
            spacerDict -> generated by spacerExtract()
            averageLength -> average length of the spacers
            outFasta -> file where the sequence of all the spacers will be written in fasta format
        
        output:

    '''

    outlier = 'F'
    outlierList = []
    lengthList = []
    for key in spacerDict:
        if spacerDict[key][1] > averageLength*float(1.5) or spacerDict[key][1] < averageLength/float(1.5):
            outlier = 'T'
            outlierList.append(key)
            lengthList.append(spacerDict[key][1])
    if outlier == 'T':
        print('\n#####################\n\n\
        WARNING:\n\
        It was detected that the following spacer(s) is(are) at least 1.5 time longer or shorter than the average spacer size (%s): \
        \n\n\t\tSpacerId\t\t\t\t\t\tLength\n' % averageLength)
        for itA, itB in zip(outlierList, lengthList):
            print('\t\t%s\t%s'  % (itA, itB))
        print('\n\tPlease verify that these spacers are correct in the fasta file %s\n\t\
and rerun the script by specifying the verified fasta file with the flag -f\n\n\
#####################' % outFasta)
        sys.exit()
        

def writeFasta(spacerDict, outFasta):
    with open(outFasta, 'w') as out:
        for it in spacerDict:
            out.write('>%s\n%s\n' % (it, spacerDict[it][0]))

def readCorrectedFasta(correctedFasta):
    spacerDict = OrderedDict() # create an empty dictionnary
    isolateList = [] # create an empty list for the isolates
    crArrayList = [] # create an empty list or the CRISPR array
    spacerLength = [] # create an empty list to store the spacer length to calculate the average length
    with open(correctedFasta, 'rU') as fl:
        for line in fl:
            if re.match('>', line):
                array = line.strip().split(':')
                sId = line.strip()[1:]
                orientation = str(array[2])
                sLen = int(array[1])
                isolate=sId.split('||')[0]
                crId= isolate+'||'+ sId.split('||')[1].split('_')[0]
                crArrayList.append(crId)
                isolateList.append(isolate)
            else:
                sSeq = line.strip()
                spacerDict[sId]=[sSeq, sLen, orientation]
            spacerLength.append(sLen)
    averageLength = sum(spacerLength)/float(len(spacerLength))


    return spacerDict, isolateList, averageLength, crArrayList

def fastaAlign(outFasta):
    query= outFasta
    subject= outFasta
    outfmt=str(8)
    outFile=outFasta+'_fasta36'
    try:
        print('Aligning the spacers with fasta aligner')
        subprocess.check_output('fasta36 -m '+outfmt +' '+  query + ' ' + subject + ' >'+outFile , shell=True)
    except:
        print("##### ERROR #####\nfasta36 alignment program was not found, please make sure that the latest version of fasta is installed on your system and that the folder with the executable was added in your path\nThe sofware can be downloaded at http://faculty.virginia.edu/wrpearson/fasta/CURRENT/")
        sys.exit()

def extractMatch(alnFile, cutoff, spacerDict):
    outFile = open(alnFile+'.spacermatch', 'w')
    with open(alnFile, 'rU') as bl:
        for line in bl:
            array = line.strip().split()
            query = array[0]
            qLen = spacerDict[query][1]
            subject = array[1]
            alnLen = int(array[3])
            mis =  int(array[4])
            gap =  int(array[5])
            score = qLen - (alnLen - gap - mis)
            if  score <= cutoff:
                outFile.write('%s\t%s\n' % (query, subject))

def mclCluster(spacermatch):
    outFile= spacermatch+'.mcl'
    try:
        print('Clustering the spacers using MCL')
        subprocess.check_output('mcl %s --abc -I 1.2 -o %s' % (spacermatch, outFile), shell=True)
    except:
        print("##### ERROR #####\nmcl clustering program was not found, please make sure that the latest version was installed on your system and that the folder with the executable was added in your path\nThe sofware can be downloaded at https://micans.org/mcl/ or it can be installed through MacPorts")

def gen_hex_colour_code():
   return ''.join([random.choice('0123456789abcdef') for x in range(3)])

def attributeClsColor(mclFile, spacerDict):
    cl = 0
    colFrList = ['666','999']
    colBkList = ['666','999']
    outFile = open(mclFile+'.col', 'w')
    with open(mclFile, 'rU') as fl:
        for line in fl:
            cl += 1
            clName = 'cls_%04d' % cl
            array = line.strip().split()
            colFr = gen_hex_colour_code()
            colBk = gen_hex_colour_code()
            while colFr in colFrList:
                colFr = gen_hex_colour_code()
            while colBk in colBkList:
                colBk = gen_hex_colour_code()
            for it in array:
                spacerDict[it].extend([colBk, colFr, clName])
            outFile.write('%s\t%s\t%s\n' % (colBk, colFr, '\t'.join(array)))
    return spacerDict

def attributeClsColorRerun(mclFile, spacerDict, finalFile):
    cl = 0
    colFrList = ['666','999']
    colBkList = ['666','999']
    colDict = {}
    outFile = open(mclFile+'.col', 'w')
    lineList = []
    with open(finalFile, 'rU') as fl: 
        for line in fl:
            array = line.strip().split()
            spacer = array[0]
            colBk = array[4]
            colFr = array[5]
            colFrList.append(colFr)
            colBkList.append(colBk)
            colDict[spacer] = [colBk, colFr]
    with open(mclFile, 'rU') as fl:
        for line in fl:
            cl += 1
            clName = 'cls_%04d' % cl
            array = line.strip().split()
            oldSpacer = ['F','']
            colFr = gen_hex_colour_code()
            colBk = gen_hex_colour_code()
            for spacer in array:
                if spacer in colDict.keys():
                    oldSpacer= ['T',spacer]
                    break
            if oldSpacer[0] == 'T':
                colBk = colDict[oldSpacer[1]][0]
                colFr = colDict[oldSpacer[1]][1]
                for spacer in array:
                    item = '%s\t%s\t%s\n' % (colBk, colFr, '\t'.join(array))
                    spacerDict[spacer].extend([colBk, colFr, clName])
                    lineList.append(item)
            else:
                colFr = gen_hex_colour_code()
                colBk = gen_hex_colour_code()
                while colFr in colFrList:
                    colFr = gen_hex_colour_code()
                while colBk in colBkList:
                    colBk = gen_hex_colour_code()
                for it in array:
                    spacerDict[it].extend([colBk, colFr, clName])
                item = '%s\t%s\t%s\n' % (colBk, colFr, '\t'.join(array))
                lineList.append(item)
        lineList= list(set(lineList))
        for it in lineList:
            outFile.write('%s\n' % it)
    return spacerDict

def reformatData(spacerDict, outFile):
    finalDict = OrderedDict()
    curIsolate = ""
    curCRid = ''
    maxSpacerCount = 0
    maxLociCount = 0
    spacerCount = 0
    lociCount = 0
    outFile = open(outFile, 'w')
    for spacer in spacerDict:
        isolate=spacer.split('||')[0]
        CRid = spacer.split('||')[1].split('_')[0]
        apList= spacerDict[spacer]
        l = [spacer]
        apList = l + apList
        if isolate != curIsolate:
            if spacerCount > maxSpacerCount:
                maxSpacerCount = spacerCount
            if lociCount > maxLociCount:
                maxLociCount = lociCount
            spacerCount = 1
            lociCount = 1
            curIsolate = isolate
            finalDict[isolate] = OrderedDict()
            curCRid = CRid
            finalDict[isolate][CRid]=[]
            finalDict[isolate][CRid].append(apList)
        elif isolate == curIsolate:
            if CRid == curCRid:
                spacerCount += 1
                finalDict[isolate][CRid].append(apList)
            elif CRid != curCRid:
                if spacerCount > maxSpacerCount:
                    maxSpacerCount = spacerCount
                spacerCount = 1
                lociCount += 1
                curCRid = CRid
                finalDict[isolate][CRid]=[]
                finalDict[isolate][CRid].append(apList)
    for isolate in finalDict:
        for cr in finalDict[isolate]:
            for spacer in finalDict[isolate][cr]:
                outFile.write('%s\t%s\t%s\t%s\n' % (spacer[0], spacer[1], str(spacer[2]), '\t'.join(spacer[3:])))
    return finalDict, maxSpacerCount, maxLociCount

def seriation(Z,N,cur_index):
    '''
        input:
            - Z is a hierarchical tree (dendrogram)
            - N is the number of points given to the clustering process
            - cur_index is the position in the tree for the recursive traversal
        output:
            - order implied by the hierarchical tree Z

        seriation computes the order implied by a hierarchical tree (dendrogram)
        source : https://gmarti.gitlab.io/ml/2017/09/07/how-to-sort-distance-matrix.html
    '''

    if cur_index < N:
        return [cur_index]
    else:
        left = int(Z[cur_index-N,0])
        right = int(Z[cur_index-N,1])
        return (seriation(Z,N,left) + seriation(Z,N,right))
    
def classifyCluster(finalDict):
    try:
        import numpy as np 
    except ImportError:
        print('#####################\n  ERROR:  The module numpy is not installed\n\
          Please install the module and rerun the script\n#####################')
        sys.exit()
    try:
        from scipy.spatial import distance
        from scipy.spatial.distance import  squareform, pdist
    except ImportError:
        print('#####################\n  ERROR:  The module scipy is not installed\n\
          Please install the module and rerun the script\n#####################')
        sys.exit()

    try:
        from fastcluster import linkage
    except ImportError:
        print('#####################\n  ERROR:  The module fastcluster is not installed\n\
          Please install the module and rerun the script\n#####################')
        sys.exit()
    clusterDict = {}
    clusterList = []
    isolateList = []
    for isolate in finalDict:
        isolateList.append(isolate)
        clusterDict[isolate]=[]
        for cr in finalDict[isolate] :
            for spacer in finalDict[isolate][cr]:
                clusterDict[isolate].append(spacer[5])
                clusterList.append(spacer[5])

    matrix = []
    for isolate in isolateList:
        tempList = []
        for cluster in clusterList:
            if cluster in clusterDict[isolate]:
                tempList.append(1)
            else:
                tempList.append(0)
        matrix.append(tempList)

    dist_mat = squareform(pdist(matrix))
    N = len(dist_mat)
    method="complete"
    res_linkage = linkage(dist_mat, method=method,preserve_input=True)
    res_order = seriation(res_linkage, N, N + N-2)
    seriated_dist = np.zeros((N,N))
    a,b = np.triu_indices(N,k=1)
    dist_mat[ [res_order[i] for i in a], [res_order[j] for j in b]]
    seriated_dist[a,b] = dist_mat[ [res_order[i] for i in a], [res_order[j] for j in b]]
    seriated_dist[b,a] = seriated_dist[a,b]
    map_index = {k: v for (k,v) in zip(isolateList, res_order)}
    orderedIsolates = sorted(map_index, key=map_index.__getitem__)

    return orderedIsolates

def gray(finalDict, isolateList):
    clusterList = []
    for isolate in isolateList:
        for cr in finalDict[isolate]:
            for spacer in finalDict[isolate][cr]:
                clusterList.append(spacer[6])
    counts = Counter(clusterList)
    print(counts)
    grayList=[]
    for cl in counts:
        if counts[cl] == 1:
            grayList.append(cl)
    return grayList
            
def generateSVG(finalDict, outFile, maxSpacerCount, maxLociCount, isolateList, grayList):
    outFile = open(outFile, 'w')
    outFile.write('<svg>\n')
    count_yaxis = 0
    count_xaxis = 0
    cr_xaxis = 500
    lociList = []
    i = 1
    while i <= maxLociCount:
        lociList.append('CRISPR'+str(i))
        i += 1
    for i, crLocus in enumerate(lociList):
        count_yaxis = 0
        maxLen = 0
        for isolate in isolateList:
            if isolate not in finalDict.keys():
                if i == 0:
                    outFile.write("<text x=\"%s\" y=\"%s\" width=\"1.6\" height=\"4\" font-family=\"Verdana\" font-size=\"7\" fill=\"black\">%s</text>\n" % (cr_xaxis, str(count_yaxis + 6.5), isolate))
                    count_yaxis += 10
                else:
                    count_yaxis += 10

            elif isolate in finalDict.keys():
                if i == 0 :
                    outFile.write("<text x=\"%s\" y=\"%s\" width=\"1.6\" height=\"4\" font-family=\"Verdana\" font-size=\"7\" fill=\"black\">%s</text>\n" % (cr_xaxis, str(count_yaxis + 6.5), isolate))
                count_xaxis = cr_xaxis - 7.5
                if crLocus in finalDict[isolate]:
                    arrayLen = len(finalDict[isolate][crLocus])
                    arrayOrientation = finalDict[isolate][crLocus][0][3]
                    if arrayLen > maxLen:
                        maxLen = arrayLen
                    if arrayOrientation == '-':
                        finalDict[isolate][crLocus] = finalDict[isolate][crLocus][::-1]

                    for spacer in finalDict[isolate][crLocus]:
                        if len(finalDict[isolate][crLocus][arrayLen-1]) != 7:
                            print('#####################\n  ERROR:  This spacer was not attributed to a cluster\n    Please verify the gff file or the fasta file and rerun CRISPR_Studio\n    %s\n#####################' % finalDict[isolate][crLocus][arrayLen-1])
                            sys.exit()  
                        else:
                            if finalDict[isolate][crLocus][arrayLen-1][6] in grayList:                        
                                outFile.write("<rect x=\"%s\" y=\"%s\" stroke=\"black\" stroke-width=\"0.2\" width=\"7.5\" height=\"7.5\" style=\"fill:#666\" />\n" % (str(count_xaxis), str(count_yaxis)))
                                outFile.write("<polygon points=\"%s,%s %s,%s %s,%s %s,%s\" stroke=\"black\" stroke-width=\"0.2\" width=\"7.5\" height=\"7.5\" style=\"fill:#999\"/>\n" % (str(count_xaxis + 1), str(count_yaxis + 3.75),  str(count_xaxis + 3.75), str(count_yaxis + 1), str(count_xaxis + 6.5), str(count_yaxis + 3.75), str(count_xaxis +3.75), str(count_yaxis + 6.5)))
                            else:
                                outFile.write("<rect x=\"%s\" y=\"%s\" stroke=\"black\" stroke-width=\"0.2\" width=\"7.5\" height=\"7.5\" style=\"fill:#%s\" />\n" % (str(count_xaxis), str(count_yaxis), finalDict[isolate][crLocus][arrayLen-1][4]))
                                outFile.write("<polygon points=\"%s,%s %s,%s %s,%s %s,%s\" stroke=\"black\" stroke-width=\"0.2\" width=\"7.5\" height=\"7.5\" style=\"fill:#%s\"/>\n" % (str(count_xaxis + 1), str(count_yaxis + 3.75),  str(count_xaxis + 3.75), str(count_yaxis + 1), str(count_xaxis + 6.5), str(count_yaxis + 3.75), str(count_xaxis +3.75), str(count_yaxis + 6.5), finalDict[isolate][crLocus][arrayLen-1][5]))
                        count_xaxis -= 7.5
                        arrayLen -= 1
                    count_yaxis += 10
                else:
                    count_yaxis += 10
        cr_xaxis += (maxLen * -7.5) -20
    outFile.write("</svg>")

def appendSVGfile(finalDict, svgBkup, outFile, maxSpacerCount, maxLociCount, isolateList, grayList):
    outFile = open(outFile, 'w')
    oldIsolateList = []
    maxY = 0
    with open(svgBkup, 'rU') as svg:
        for line in svg:
            if line.strip() != '</svg>':
                outFile.write(line)
                if re.match('<rect', line):
                    maxY = int(line.split()[2][3:-1])
                if re.match('<text', line):
                    array = line.strip().split('>')
                    isolate = array[1][:-6]
                    oldIsolateList.append(isolate)
    count_yaxis = maxY
    count_xaxis = 0
    cr_xaxis = 500
    lociList = []
    i = 1
    while i <= maxLociCount:
        lociList.append('CRISPR'+str(i))
        i += 1
    for i, crLocus in enumerate(lociList):
        count_yaxis = maxY + 10
        maxLen = 0
        for isolate in isolateList:
            if isolate in oldIsolateList:
                continue
            if isolate not in finalDict.keys():
                if i == 0:
                    outFile.write("<text x=\"%s\" y=\"%s\" width=\"1.6\" height=\"4\" font-family=\"Verdana\" font-size=\"7\" fill=\"black\">%s</text>\n" % (cr_xaxis, str(count_yaxis + 6.5), isolate))
                    count_yaxis += 10
                else:
                    count_yaxis += 10

            elif isolate in finalDict.keys():
                if i == 0 :
                    outFile.write("<text x=\"%s\" y=\"%s\" width=\"1.6\" height=\"4\" font-family=\"Verdana\" font-size=\"7\" fill=\"black\">%s</text>\n" % (cr_xaxis, str(count_yaxis + 6.5), isolate))
                count_xaxis = cr_xaxis - 7.5
                if crLocus in finalDict[isolate]:
                    arrayLen = len(finalDict[isolate][crLocus])
                    arrayOrientation = finalDict[isolate][crLocus][0][3]
                    if arrayLen > maxLen:
                        maxLen = arrayLen
                    if arrayOrientation == '-':
                        finalDict[isolate][crLocus] = finalDict[isolate][crLocus][::-1]

                    for spacer in finalDict[isolate][crLocus]:
                        if finalDict[isolate][crLocus][arrayLen-1][6] in grayList:                        
                            outFile.write("<rect x=\"%s\" y=\"%s\" stroke=\"black\" stroke-width=\"0.2\" width=\"7.5\" height=\"7.5\" style=\"fill:#666\" />\n" % (str(count_xaxis), str(count_yaxis)))
                            outFile.write("<polygon points=\"%s,%s %s,%s %s,%s %s,%s\" stroke=\"black\" stroke-width=\"0.2\" width=\"7.5\" height=\"7.5\" style=\"fill:#999\"/>\n" % (str(count_xaxis + 1), str(count_yaxis + 3.75),  str(count_xaxis + 3.75), str(count_yaxis + 1), str(count_xaxis + 6.5), str(count_yaxis + 3.75), str(count_xaxis +3.75), str(count_yaxis + 6.5)))
                        else:
                            outFile.write("<rect x=\"%s\" y=\"%s\" stroke=\"black\" stroke-width=\"0.2\" width=\"7.5\" height=\"7.5\" style=\"fill:#%s\" />\n" % (str(count_xaxis), str(count_yaxis), finalDict[isolate][crLocus][arrayLen-1][4]))
                            outFile.write("<polygon points=\"%s,%s %s,%s %s,%s %s,%s\" stroke=\"black\" stroke-width=\"0.2\" width=\"7.5\" height=\"7.5\" style=\"fill:#%s\"/>\n" % (str(count_xaxis + 1), str(count_yaxis + 3.75),  str(count_xaxis + 3.75), str(count_yaxis + 1), str(count_xaxis + 6.5), str(count_yaxis + 3.75), str(count_xaxis +3.75), str(count_yaxis + 6.5), finalDict[isolate][crLocus][arrayLen-1][5]))
                        count_xaxis -= 7.5
                        arrayLen -= 1
                    count_yaxis += 10
                else:
                    count_yaxis += 10
        cr_xaxis += (maxLen * -7.5) -20
    outFile.write("</svg>")
                    
def main():
    parser = argparse.ArgumentParser(description='Description: CRISPR Studio generates a figure comparing the different CRISPR array identified by CRISPRDetect. Required File: GFF3 file with the CRISPR arrays identified with CRISPRDetect.')
    parser.add_argument("-i", "--inFile", dest="inFile",
                        help="GFF3 file generated with CRISPRDetect", metavar="FILE")
    parser.add_argument("-l", "--listOfIsolates", dest='isolateFile', metavar='FILE', 
                        help="CRISPR_Studio will generate the figure with a subset of isolates listed in the file  (Optional: By default, CRISPR_Studio will generate a figure with all the isolates).")
    parser.add_argument("-g", '--grayOut', dest='gray', help='The uniq spacers will be grayed (Optional: by default, CRISPR_Studio attribute a uniq color for each cluster of spacer.)', action='store_true')
    parser.add_argument("-f", '--checkFasta', dest='checkFasta', help='Verification of the fasta file generated from the GFF file will be skipped if this flag is provided. The verification is mainly based on the lenght of the spacer sequences. If a spacer is 1.5 time shorter or longer than the average spacer size of the dataset, a warning is raised and the script stops (Verification is ran by default). Correction can be either made in the initial gff file or in the fasta file. If the later, provide the name of the fasta file after the flag (ex. -f corrected_sequences.fasta', action='store_true')
    parser.add_argument("-s", '--sort', dest='sort', help='The order of the isolates in the figure: Available option: CRISPRDetect, HClust, File prividing a list of the isolates in the desired order. CRISPRDetect = order in the gff file. HClust = Order based on hiearchical clustering of a distance matrix. File = Order privided in a single column file with the isolates names as they should appear in the figure. The option -l overrides this option (Default: CRISPRDetect)')
    parser.add_argument("-r", '--rerun', dest='rerun', help='Use this option to keep the same color attributed to the spacer during a previous analysis', action='store_true')
    parser.add_argument("-c", '--cutoff', dest='cutoff', help='Set to score cutoff for pairing of the spaces (default = 2)')
    args = parser.parse_args()
    appendSVG = False
    if not len(sys.argv) > 1:
        parser.print_help()
        sys.exit()

    if args.inFile:
        inFile = args.inFile
    else:
        parser.print_help()
        sys.exit()

    outFasta=inFile+'.fasta'

    if not args.checkFasta:
        spacerDict, isolateList, averageLength, crArrayList = spacerExtract(inFile)
        writeFasta(spacerDict, outFasta)
        checkSpacer(spacerDict, averageLength, outFasta)
    elif args.checkFasta:
        print('\n\tTHE FLAG -f (--checkFasta) WAS USED, NO VERIFICATION OF THE FASTA FILE WILL BE RUN')
        print('\tIf you want CRISPR_Studio to extract the spacer from the gff file')
        print('\twithout runing the verification step, just hit enter (leave the field empty)')
        correctedFasta = input('\n\tPlease enter the name of the corrected fasta file: ')
        if len(correctedFasta) > 1:
            spacerDict, isolateList, averageLength, crArrayList = readCorrectedFasta(correctedFasta)
        else:
            spacerDict, isolateList, averageLength, crArrayList = spacerExtract(inFile)
            writeFasta(spacerDict, outFasta)
        
    fastaAlign(outFasta)

    if args.cutoff:
        extractMatch(outFasta+'_fasta36', int(args.cutoff) , spacerDict)
    else:
        extractMatch(outFasta+'_fasta36', 2, spacerDict)

    mclCluster(outFasta+'_fasta36.spacermatch')

    if args.rerun:
        os.rename(outFasta+'_fasta36.spacermatch.mcl.svg',outFasta+'_fasta36.spacermatch.mcl.svg.bkup')
        print('\n\tTHE FLAG -r (--rerun) WAS USED. The color used to represent the spacer of the first figure will be preserved.\n\
CRISPR_Studio can append the new CRISPR loci to the initial figure.')
        appendSVG = input('Do you want to append the new spacer at the bottom of the initial figure? (y/n) ')
        while len(appendSVG) < 1:
            appendSVG = input('Please provide and answer. Do you want to append the new spacer at the bottom of the initial figure? (y/n)')   
        if appendSVG.lower() == 'n' or appendSVG.lower() == 'no':
            clDict= attributeClsColorRerun( outFasta+'_fasta36.spacermatch.mcl', spacerDict, outFasta+'_fasta36.spacermatch.mcl.final')
            appendSVG = False
        elif appendSVG.lower() == 'y' or appendSVG.lower() == 'yes':
            clDict = attributeClsColorRerun( outFasta+'_fasta36.spacermatch.mcl', spacerDict, outFasta+'_fasta36.spacermatch.mcl.final')
            appendSVG = True
    else:
        clDict = attributeClsColor(outFasta+'_fasta36.spacermatch.mcl', spacerDict)


    spacerList = sorted(clDict.keys())
    finalDict, maxSpacerCount, maxLociCount = reformatData(clDict, outFasta+'_fasta36.spacermatch.mcl.final')

    if args.isolateFile:
        orderedIsolates = []
        with open(args.isolateFile, 'rU') as fl :
            for line in fl:
                orderedIsolates.append(line.strip())
    else:
        if not args.sort:
            args.sort = 'CRISPRDetect'
        if args.sort == 'CRISPRDetect':
            orderedIsolates = isolateList
        elif args.sort == 'HClust':
            orderedIsolates = classifyCluster(finalDict)
        else:
            orderedIsolates = []
            with open(args.sort, 'rU') as fl:
                for line in fl:
                    orderedIsolates.append(line.strip())
                    
    if args.gray:
        grayList = gray(finalDict, orderedIsolates)
    else:
        grayList = []

    if appendSVG == False:
        generateSVG(finalDict, outFasta+'_fasta36.spacermatch.mcl.svg', maxSpacerCount, maxLociCount, orderedIsolates, grayList)
    elif appendSVG == True:
        appendSVGfile(finalDict, outFasta+'_fasta36.spacermatch.mcl.svg.bkup', outFasta+'_fasta36.spacermatch.mcl.svg', maxSpacerCount, maxLociCount, orderedIsolates, grayList)
        
if __name__=='__main__':

    main()





    

